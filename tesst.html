<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>I ‚ù§Ô∏è U</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="heartCanvas"></canvas>

    <script>
      const canvas = document.getElementById("heartCanvas");
      const ctx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const CANVAS_WIDTH = canvas.width;
      const CANVAS_HEIGHT = canvas.height;
      const CANVAS_CENTER_X = CANVAS_WIDTH / 2;
      const CANVAS_CENTER_Y = CANVAS_HEIGHT / 2;
      const IMAGE_ENLARGE = 11;

      // üé® Nhi·ªÅu m√†u s·∫Øc
      const COLORS = ["red", "deeppink", "orange", "yellow", "violet", "cyan"];

      const EXPLODE_START = 12;
      const EXPLODE_END = 40;
      const GATHER_DURATION = 20;

      function heartFunction(t, shrinkRatio = IMAGE_ENLARGE) {
        let x = 16 * Math.pow(Math.sin(t), 3);
        let y = -(
          13 * Math.cos(t) -
          5 * Math.cos(2 * t) -
          2 * Math.cos(3 * t) -
          Math.cos(4 * t)
        );
        x *= shrinkRatio;
        y *= shrinkRatio;
        x += CANVAS_CENTER_X;
        y += CANVAS_CENTER_Y;
        return [x, y];
      }

      function scatterInside(x, y, beta = 0.15) {
        const ratioX = -beta * Math.log(Math.random());
        const ratioY = -beta * Math.log(Math.random());
        const dx = ratioX * (x - CANVAS_CENTER_X);
        const dy = ratioY * (y - CANVAS_CENTER_Y);
        return [x - dx, y - dy];
      }

      function shrink(x, y, ratio) {
        const force =
          -1 /
          Math.pow(
            (x - CANVAS_CENTER_X) ** 2 + (y - CANVAS_CENTER_Y) ** 2,
            0.6
          );
        const dx = ratio * force * (x - CANVAS_CENTER_X);
        const dy = ratio * force * (y - CANVAS_CENTER_Y);
        return [x - dx, y - dy];
      }

      function curve(p) {
        return (2 * (2 * Math.sin(4 * p))) / (2 * Math.PI);
      }

      class Heart {
        constructor(generateFrame = 40) {
          this.points = new Set();
          this.edgePoints = new Set();
          this.centerPoints = new Set();
          this.allPoints = {};
          this.explodePositions = {};
          this.build(2000);
          this.generateFrame = generateFrame + GATHER_DURATION + 120;
          for (let f = 0; f < this.generateFrame; f++) {
            this.calc(f);
          }
        }

        build(number) {
          for (let i = 0; i < number; i++) {
            const t = Math.random() * 2 * Math.PI;
            const z = Math.random() * Math.PI;
            let [x, y] = heartFunction(t);
            let [a, b] = heartFunction(z);
            this.points.add([x, y]);
            this.points.add([a, b]);
          }

          this.points.forEach(([x, y]) => {
            for (let i = 0; i < 3; i++) {
              this.edgePoints.add(scatterInside(x, y, 0.1));
            }
          });

          const pointList = Array.from(this.points);
          for (let i = 0; i < 400; i++) {
            let [x, y] =
              pointList[Math.floor(Math.random() * pointList.length)];
            this.centerPoints.add(scatterInside(x, y, 0.1));
          }
        }

        calcPosition(x, y, ratio) {
          const force =
            1 /
            Math.pow(
              (x - CANVAS_CENTER_X) ** 2 + (y - CANVAS_CENTER_Y) ** 2,
              0.52
            );
          const dx = ratio * force * (x - CANVAS_CENTER_X) + 1;
          const dy = ratio * force * (y - CANVAS_CENTER_Y) + 1;
          return [x - dx, y - dy];
        }

        interpolate(x1, y1, x2, y2, progress) {
          const x = x1 + (x2 - x1) * progress;
          const y = y1 + (y2 - y1) * progress;
          return [x, y];
        }

        calc(frame) {
          const ratio = 10 * curve((frame / 20) * Math.PI); // ‚ö° gi·∫£m t·ªëc ƒë·ªô nh·ªãp
          const haloRadius = Math.floor(
            40 + 6 * (1 + curve((frame / 40) * Math.PI))
          );
          const haloNumber = Math.floor(
            3000 + 4000 * Math.abs(Math.pow(curve((frame / 20) * Math.PI), 2))
          );
          let allPoints = [];

          const heartHalo = new Set();
          for (let i = 0; i < haloNumber; i++) {
            const t = Math.random() * 2 * Math.PI;
            let [x, y] = heartFunction(t, 11.6);
            [x, y] = shrink(x, y, haloRadius);
            if (!heartHalo.has(`${x},${y}`)) {
              heartHalo.add(`${x},${y}`);
              x += Math.floor(Math.random() * 28) - 14;
              y += Math.floor(Math.random() * 28) - 14;
              const size = Math.random() > 0.5 ? 2 : 1;
              allPoints.push([x, y, size]);
            }
          }

          const explode = (x, y) => {
            const angle = Math.random() * 2 * Math.PI;
            const radius =
              Math.random() * (CANVAS_WIDTH - CANVAS_WIDTH * 0.6) +
              CANVAS_WIDTH * 0.6;
            return [x + radius * Math.cos(angle), y + radius * Math.sin(angle)];
          };

          const applyPoints = (pointSet) => {
            pointSet.forEach(([x, y]) => {
              let size = Math.floor(Math.random() * 3) + 1;
              let key = `${x},${y}`;
              if (frame < EXPLODE_START) {
                [x, y] = this.calcPosition(x, y, ratio);
              } else if (frame < EXPLODE_END) {
                if (!(key in this.explodePositions)) {
                  this.explodePositions[key] = explode(x, y);
                }
                [x, y] = this.explodePositions[key];
              } else if (frame < EXPLODE_END + GATHER_DURATION) {
                if (!(key in this.explodePositions)) {
                  this.explodePositions[key] = explode(x, y);
                }
                const [xExp, yExp] = this.explodePositions[key];
                const progress = (frame - EXPLODE_END) / GATHER_DURATION;
                [x, y] = this.interpolate(xExp, yExp, x, y, progress);
              } else {
                [x, y] = this.calcPosition(x, y, ratio);
              }
              allPoints.push([x, y, size]);
            });
          };

          applyPoints(this.points);
          applyPoints(this.edgePoints);
          applyPoints(this.centerPoints);

          this.allPoints[frame] = allPoints;
        }

        render(frame) {
          ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
          const points = this.allPoints[frame % this.generateFrame];
          points.forEach(([x, y, size]) => {
            // üåà ch·ªçn m√†u ng·∫´u nhi√™n
            // ctx.fillStyle = COLORS[Math.floor(Math.random() * COLORS.length)];
            ctx.fillStyle = "#c72c53";
            ctx.fillRect(x, y, size, size);
          });

          ctx.fillStyle = "white";
          ctx.font = "64px Arial";
          ctx.fillText("I", CANVAS_CENTER_X - 300, CANVAS_CENTER_Y);
          ctx.fillText("U", CANVAS_CENTER_X + 250, CANVAS_CENTER_Y);
        }
      }

      const heart = new Heart();
      let frame = 0;

      function animate() {
        heart.render(frame);
        frame++;
        setTimeout(() => requestAnimationFrame(animate), 40); // üê¢ ch·∫≠m h∆°n
      }

      animate();
    </script>
  </body>
</html>
